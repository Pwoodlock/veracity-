# frozen_string_literal: true

require 'open3'

module Settings
  class VulnerabilityLookupController < ApplicationController
    before_action :authenticate_user!
    before_action :authorize_admin!

    def index
      # Get settings with source tracking (ENV vs DB)
      @vulnerability_lookup_url = SystemSetting.get_with_source('vulnerability_lookup_url', 'https://vulnerability.circl.lu')
      @vulnerability_lookup_enabled = SystemSetting.get_with_source('vulnerability_lookup_enabled', true)
      @vulnerability_lookup_scan_schedule = SystemSetting.get_with_source('vulnerability_lookup_scan_schedule', '0 2 * * *')
      @vulnerability_lookup_notification_threshold = SystemSetting.get_with_source('vulnerability_lookup_notification_threshold', 'high')
      @vulnerability_lookup_python_path = SystemSetting.get_with_source('vulnerability_lookup_python_path', '/opt/server-manager/cve_venv/bin/python')
      @vulnerability_lookup_timeout = SystemSetting.get_with_source('vulnerability_lookup_timeout', 120)

      # Get Python environment info
      @python_info = get_python_environment_info

      # Get recent CVE scan statistics
      @recent_scans = CveScanHistory.order(created_at: :desc).limit(10)
      @total_vulnerabilities = VulnerabilityAlert.count
      @critical_vulnerabilities = VulnerabilityAlert.where(severity: 'CRITICAL').count
      @high_vulnerabilities = VulnerabilityAlert.where(severity: 'HIGH').count
      @active_watchlists = CveWatchlist.where(active: true).count

      # Get notification threshold options
      @threshold_options = [
        ['All Severities (INFO and above)', 'info'],
        ['LOW and above', 'low'],
        ['MEDIUM and above', 'medium'],
        ['HIGH and above', 'high'],
        ['CRITICAL only', 'critical']
      ]
    end

    def update
      begin
        # Check if any ENV overrides are active
        env_overrides = []
        env_overrides << 'API URL' if SystemSetting.env_override?('vulnerability_lookup_url')
        env_overrides << 'Enabled' if SystemSetting.env_override?('vulnerability_lookup_enabled')
        env_overrides << 'Scan Schedule' if SystemSetting.env_override?('vulnerability_lookup_scan_schedule')
        env_overrides << 'Notification Threshold' if SystemSetting.env_override?('vulnerability_lookup_notification_threshold')
        env_overrides << 'Python Path' if SystemSetting.env_override?('vulnerability_lookup_python_path')
        env_overrides << 'Timeout' if SystemSetting.env_override?('vulnerability_lookup_timeout')

        if env_overrides.any?
          flash[:warning] = "Some settings (#{env_overrides.join(', ')}) are controlled by environment variables and cannot be changed via UI."
          redirect_to settings_vulnerability_lookup_path
          return
        end

        # Update API URL
        if params[:vulnerability_lookup_url].present?
          url = sanitize_url(params[:vulnerability_lookup_url])
          SystemSetting.set('vulnerability_lookup_url', url, 'string')
        end

        # Update enabled status
        enabled = params[:vulnerability_lookup_enabled] == '1' || params[:vulnerability_lookup_enabled] == 'true'
        SystemSetting.set('vulnerability_lookup_enabled', enabled, 'boolean')

        # Update scan schedule (validate cron expression)
        if params[:vulnerability_lookup_scan_schedule].present?
          schedule = params[:vulnerability_lookup_scan_schedule].strip
          if valid_cron_expression?(schedule)
            SystemSetting.set('vulnerability_lookup_scan_schedule', schedule, 'string')
          else
            flash[:error] = 'Invalid cron expression. Please use a valid format (e.g., "0 2 * * *" for daily at 2 AM).'
            redirect_to settings_vulnerability_lookup_path
            return
          end
        end

        # Update notification threshold
        if params[:vulnerability_lookup_notification_threshold].present?
          threshold = params[:vulnerability_lookup_notification_threshold]
          if %w[info low medium high critical].include?(threshold)
            SystemSetting.set('vulnerability_lookup_notification_threshold', threshold, 'string')
          else
            flash[:error] = 'Invalid notification threshold value.'
            redirect_to settings_vulnerability_lookup_path
            return
          end
        end

        # Update Python path
        if params[:vulnerability_lookup_python_path].present?
          python_path = params[:vulnerability_lookup_python_path].strip
          SystemSetting.set('vulnerability_lookup_python_path', python_path, 'string')
        end

        # Update timeout
        if params[:vulnerability_lookup_timeout].present?
          timeout = params[:vulnerability_lookup_timeout].to_i
          if timeout > 0 && timeout <= 600
            SystemSetting.set('vulnerability_lookup_timeout', timeout, 'integer')
          else
            flash[:error] = 'Timeout must be between 1 and 600 seconds.'
            redirect_to settings_vulnerability_lookup_path
            return
          end
        end

        # Restart scheduled jobs if schedule changed
        if params[:vulnerability_lookup_scan_schedule].present?
          restart_scheduler if defined?(Sidekiq)
        end

        flash[:notice] = 'Vulnerability Lookup settings updated successfully'
        redirect_to settings_vulnerability_lookup_path
      rescue StandardError => e
        Rails.logger.error "Failed to update Vulnerability Lookup settings: #{e.message}"
        flash[:error] = "Failed to update settings: #{e.message}"
        redirect_to settings_vulnerability_lookup_path
      end
    end

    def test_connection
      begin
        url = SystemSetting.get('vulnerability_lookup_url', 'https://vulnerability.circl.lu')
        timeout = SystemSetting.get('vulnerability_lookup_timeout', 120)

        # Test the API by checking if it's responding
        result = CveMonitoringService.test_api_connection(url, timeout)

        if result[:success]
          render json: {
            success: true,
            message: "Connection successful! API is responding. Version: #{result[:version] || 'unknown'}",
            api_version: result[:version]
          }
        else
          render json: {
            success: false,
            message: result[:message] || 'Connection test failed'
          }, status: :unprocessable_entity
        end
      rescue StandardError => e
        Rails.logger.error "Vulnerability Lookup connection test failed: #{e.message}"
        render json: {
          success: false,
          message: "Connection test failed: #{e.message}"
        }, status: :unprocessable_entity
      end
    end

    def python_info
      begin
        info = get_python_environment_info

        render json: {
          success: info[:available],
          python_version: info[:python_version],
          pyvulnerabilitylookup_version: info[:pyvulnerabilitylookup_version],
          python_path: info[:python_path],
          message: info[:message]
        }
      rescue StandardError => e
        Rails.logger.error "Failed to get Python info: #{e.message}"
        render json: {
          success: false,
          message: "Failed to get Python info: #{e.message}"
        }, status: :unprocessable_entity
      end
    end

    def run_scan
      begin
        unless SystemSetting.get('vulnerability_lookup_enabled', true)
          redirect_to settings_vulnerability_lookup_path, alert: 'CVE scanning is disabled. Please enable it first.'
          return
        end

        # Run the scan in the background via Sidekiq
        CveScanJob.perform_later

        flash[:notice] = 'CVE scan has been queued and will run in the background. Check the scan history for results.'
        redirect_to settings_vulnerability_lookup_path
      rescue StandardError => e
        Rails.logger.error "Failed to queue CVE scan: #{e.message}"
        flash[:error] = "Failed to start scan: #{e.message}"
        redirect_to settings_vulnerability_lookup_path
      end
    end

    private

    def authorize_admin!
      unless current_user.admin?
        flash[:error] = 'You are not authorized to access this page'
        redirect_to root_path
      end
    end

    def sanitize_url(url)
      # Remove trailing slash
      url = url.strip.chomp('/')

      # Add https:// if no protocol specified
      url = "https://#{url}" unless url.start_with?('http://', 'https://')

      # Validate URL format
      uri = URI.parse(url)
      unless uri.is_a?(URI::HTTP) || uri.is_a?(URI::HTTPS)
        raise ArgumentError, 'Invalid URL format'
      end

      url
    rescue URI::InvalidURIError
      raise ArgumentError, 'Invalid URL format'
    end

    def valid_cron_expression?(cron)
      # Basic cron validation: 5 fields separated by spaces
      # Format: minute hour day_of_month month day_of_week
      parts = cron.split(/\s+/)
      return false unless parts.length == 5

      # Each part should be valid (numbers, *, /, -, ,)
      parts.all? { |part| part.match?(/^[\d\*\-\/,]+$/) }
    end

    def get_python_environment_info
      python_path = SystemSetting.get('vulnerability_lookup_python_path', '/opt/server-manager/cve_venv/bin/python')

      # Check if Python exists at specified path
      unless File.exist?(python_path)
        # Try fallback to system python3
        fallback = `which python3 2>/dev/null`.strip
        python_path = fallback if fallback.present?
      end

      begin
        # Get Python version using Open3 for better error handling
        stdout, stderr, status = Open3.capture3(python_path, '--version')
        python_version = (stdout.presence || stderr).strip

        # Check if PyVulnerabilityLookup is installed (just try to import it)
        import_stdout, import_stderr, import_status = Open3.capture3(
          python_path, '-c', 'import pyvulnerabilitylookup; print("OK")'
        )

        if import_status.success?
          # Get version from pip show command
          pip_path = File.join(File.dirname(python_path), 'pip')
          pip_path = 'pip3' unless File.exist?(pip_path)

          version_stdout, _, _ = Open3.capture3(pip_path, 'show', 'pyvulnerabilitylookup')
          version_match = version_stdout.match(/^Version:\s*(.+)$/i)
          pyvl_version = version_match ? version_match[1].strip : 'installed'

          {
            available: true,
            python_path: python_path,
            python_version: python_version,
            pyvulnerabilitylookup_version: pyvl_version,
            message: "Python environment is configured correctly"
          }
        else
          {
            available: false,
            python_path: python_path,
            python_version: python_version,
            pyvulnerabilitylookup_version: nil,
            message: "PyVulnerabilityLookup is not installed. Run: pip install pyvulnerabilitylookup"
          }
        end
      rescue StandardError => e
        Rails.logger.error "Python environment check failed: #{e.message}\n#{e.backtrace.join("\n")}"
        {
          available: false,
          python_path: python_path,
          python_version: nil,
          pyvulnerabilitylookup_version: nil,
          message: "Python environment error: #{e.message}"
        }
      end
    end

    def restart_scheduler
      # Signal Sidekiq to reload the schedule with user-configured CVE scan schedule
      begin
        # Load base schedule from YAML
        schedule = YAML.load_file(Rails.root.join('config', 'schedule.yml'))

        # Override CVE scan schedule with user configuration
        if schedule['cve_scan']
          user_schedule = SystemSetting.get('vulnerability_lookup_scan_schedule', '0 2 * * *')
          schedule['cve_scan']['cron'] = user_schedule
          Rails.logger.info "Updated CVE scan schedule to: #{user_schedule}"
        end

        # Reload all jobs
        Sidekiq::Cron::Job.load_from_hash!(schedule)
        Rails.logger.info "Sidekiq scheduler reloaded with new CVE scan schedule"
      rescue StandardError => e
        Rails.logger.warn "Could not reload Sidekiq scheduler: #{e.message}"
      end
    end
  end
end
