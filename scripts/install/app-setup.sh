#!/bin/bash
#
# app-setup.sh - Application deployment and configuration
# Clones repository, generates .env, installs dependencies, runs migrations
#

set -euo pipefail

# Source guard to prevent double-sourcing
[[ -n "${VERACITY_APP_SETUP_SOURCED:-}" ]] && return 0
readonly VERACITY_APP_SETUP_SOURCED=1

# Source common functions
SERVICE_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/common.sh
source "${SERVICE_SCRIPT_DIR}/lib/common.sh"
# shellcheck source=lib/validators.sh
source "${SERVICE_SCRIPT_DIR}/lib/validators.sh"

# Application configuration (don't redeclare if already set)
if [[ -z "${APP_DIR:-}" ]]; then
  readonly APP_DIR="/opt/veracity/app"
fi
if [[ -z "${DEPLOY_USER:-}" ]]; then
  readonly DEPLOY_USER="deploy"
fi
readonly REPO_URL="${REPO_URL:-https://github.com/Pwoodlock/veracity-.git}"
readonly REPO_BRANCH="${REPO_BRANCH:-main}"

#######################################
# Clone or update repository
#######################################
clone_repository() {
  section "Setting up Application"

  if [ -d "${APP_DIR}" ]; then
    warning "Application directory already exists: ${APP_DIR}"

    if confirm "Do you want to backup and re-clone?" "n"; then
      local backup_dir="${APP_DIR}.backup.$(date +%Y%m%d-%H%M%S)"
      step "Backing up to: ${backup_dir}"
      execute mv "${APP_DIR}" "${backup_dir}"
    else
      info "Using existing application directory"
      return 0
    fi
  fi

  step "Cloning repository from ${REPO_URL}..."

  # Clone as root first, then change ownership
  execute git clone --depth 1 --branch "${REPO_BRANCH}" "${REPO_URL}" "${APP_DIR}"

  # Remove unnecessary files to reduce disk usage (saves ~86MB)
  info "Removing unnecessary files (test, docs, .github, vendor/bundle)..."
  execute rm -rf "${APP_DIR}/test"
  execute rm -rf "${APP_DIR}/docs"
  execute rm -rf "${APP_DIR}/.github"
  execute rm -rf "${APP_DIR}/vendor/bundle"
  execute rm -rf "${APP_DIR}/node_modules" 2>/dev/null || true
  success "Removed unnecessary files (saved ~86MB)"

  # Set ownership to deploy user
  execute chown -R "${DEPLOY_USER}:${DEPLOY_USER}" "${APP_DIR}"

  success "Repository cloned successfully"
}

#######################################
# Generate .env.production file
# Globals: All configuration variables
#######################################
generate_env_file() {
  step "Generating .env.production file..."

  local env_file="${APP_DIR}/.env.production"

  # Backup existing .env if present
  if [ -f "${env_file}" ]; then
    local backup="${env_file}.backup.$(date +%Y%m%d-%H%M%S)"
    execute cp "${env_file}" "${backup}"
    info "Backed up existing .env to: ${backup}"
  fi

  # Generate .env.production
  cat > "${env_file}" << EOF
# ============================================================================
# VERACITY PRODUCTION CONFIGURATION
# Auto-generated by installer on $(date)
# ============================================================================

# ============================================================================
# RAILS CONFIGURATION
# ============================================================================
RAILS_ENV=production
RAILS_LOG_LEVEL=${RAILS_LOG_LEVEL:-info}
SECRET_KEY_BASE=${SECRET_KEY_BASE}

# Domain/Host Configuration
RAILS_HOST=${RAILS_HOST}
RAILS_PROTOCOL=${RAILS_PROTOCOL:-https}
RAILS_FORCE_SSL=${RAILS_FORCE_SSL:-true}
RAILS_SERVE_STATIC_FILES=true
RAILS_MAX_THREADS=${RAILS_MAX_THREADS:-10}

# ============================================================================
# DATABASE CONFIGURATION
# ============================================================================
DATABASE_USERNAME=${DB_USER}
DATABASE_PASSWORD=${DB_PASSWORD}
DATABASE_HOST=${DB_HOST:-localhost}

# ============================================================================
# REDIS CONFIGURATION
# ============================================================================
REDIS_URL=${REDIS_URL:-redis://localhost:6379/0}

# ============================================================================
# SALT API CONFIGURATION
# ============================================================================
SALT_API_URL=${SALT_API_URL:-http://localhost:8001}
SALT_API_USERNAME=${SALT_API_USER}
SALT_API_PASSWORD=${SALT_API_PASSWORD}
SALT_API_EAUTH=${SALT_API_EAUTH:-pam}

# ============================================================================
# EMAIL CONFIGURATION (Optional)
# ============================================================================
$(if [ -n "${SMTP2GO_USERNAME:-}" ]; then
cat << SMTP
SMTP2GO_USERNAME=${SMTP2GO_USERNAME}
SMTP2GO_PASSWORD=${SMTP2GO_PASSWORD}
MAILER_HOST=${RAILS_HOST}
MAILER_FROM=${MAILER_FROM:-noreply@${RAILS_HOST}}
SMTP
else
echo "# SMTP2GO_USERNAME="
echo "# SMTP2GO_PASSWORD="
echo "# MAILER_HOST=${RAILS_HOST}"
echo "# MAILER_FROM=noreply@${RAILS_HOST}"
fi)

# ============================================================================
# GOTIFY PUSH NOTIFICATIONS
# ============================================================================
GOTIFY_ENABLED=${GOTIFY_ENABLED:-true}
GOTIFY_URL=${GOTIFY_URL:-http://localhost:8080}
GOTIFY_APP_TOKEN=${GOTIFY_APP_TOKEN:-}
GOTIFY_SSL_VERIFY=true

# ============================================================================
# OAUTH2 / ZITADEL (Optional)
# ============================================================================
$(if [ "${OAUTH_ENABLED:-false}" = "true" ]; then
cat << OAUTH
ZITADEL_CLIENT_ID=${ZITADEL_CLIENT_ID}
ZITADEL_ISSUER=${ZITADEL_ISSUER}
OAUTH
else
echo "# ZITADEL_CLIENT_ID="
echo "# ZITADEL_ISSUER="
fi)

# ============================================================================
# CVE MONITORING
# ============================================================================
VULNERABILITY_LOOKUP_ENABLED=${CVE_ENABLED:-true}
VULNERABILITY_LOOKUP_URL=${CVE_URL:-https://vulnerability.circl.lu}
VULNERABILITY_LOOKUP_SCAN_SCHEDULE=${CVE_SCHEDULE:-0 2 * * *}
VULNERABILITY_LOOKUP_PYTHON_PATH=${VULNERABILITY_LOOKUP_PYTHON_PATH:-/opt/veracity/app/bin/cve_python}
VULNERABILITY_LOOKUP_TIMEOUT=60

# ============================================================================
# PROXMOX API (Configure via UI)
# ============================================================================
# PROXMOX_API_TOKENS stored encrypted in database

# ============================================================================
# HETZNER CLOUD (Configure via UI)
# ============================================================================
# HETZNER_API_TOKENS stored encrypted in database

# ============================================================================
# SYSTEM CONFIGURATION
# ============================================================================
TZ=${TZ:-UTC}
PORT=3000
WEB_CONCURRENCY=${WEB_CONCURRENCY:-2}
SOLID_QUEUE_IN_PUMA=false
EOF

  # Set secure permissions
  execute chown "${DEPLOY_USER}:${DEPLOY_USER}" "${env_file}"
  execute chmod 600 "${env_file}"

  success ".env.production file generated"
}

#######################################
# Install Ruby gems
#######################################
install_gems() {
  step "Installing Ruby gems (this may take 5-10 minutes)..."

  cd "${APP_DIR}"

  # Helper to run commands with rbenv loaded
  local rbenv_cmd="export PATH=\"\$HOME/.rbenv/bin:\$PATH\" && eval \"\$(rbenv init -)\" && "

  # Install gems as deploy user with timeout and retry
  # Bundle has built-in retry for gem downloads, but we add timeout protection
  info "Running bundle install (timeout: 20 minutes)..."

  # Use retry_command for network resilience
  if ! retry_command 3 5 run_with_timeout 1200 sudo -u "${DEPLOY_USER}" bash -c "${rbenv_cmd} cd ${APP_DIR} && RAILS_ENV=production bundle install --jobs=4 --retry=3 --without development test"; then
    error "Failed to install gems after multiple attempts"
    error "This may be due to:"
    error "  - Network connectivity issues"
    error "  - Gem compilation failures (check for missing system libraries)"
    error "  - Timeout (bundle install took longer than 20 minutes)"
    error "Check ${LOG_FILE} for detailed error messages"
    fatal "Failed to install gems"
  fi

  success "Gems installed successfully"
}

#######################################
# Install Node packages
#######################################
install_node_packages() {
  step "Installing Node.js packages..."

  cd "${APP_DIR}"

  # Helper to run commands with rbenv loaded
  local rbenv_cmd="export PATH=\"\$HOME/.rbenv/bin:\$PATH\" && eval \"\$(rbenv init -)\" && "

  # Install packages as deploy user with timeout and retry
  # COREPACK_ENABLE_DOWNLOAD_PROMPT=0 disables interactive Corepack prompts
  info "Running yarn install (timeout: 10 minutes)..."

  # Use retry_command for network resilience
  if ! retry_command 3 5 run_with_timeout 600 sudo -u "${DEPLOY_USER}" bash -c "${rbenv_cmd} cd ${APP_DIR} && COREPACK_ENABLE_DOWNLOAD_PROMPT=0 yarn install --frozen-lockfile"; then
    error "Failed to install Node packages after multiple attempts"
    error "This may be due to:"
    error "  - Network connectivity issues"
    error "  - yarn.lock file issues (try deleting node_modules and yarn.lock)"
    error "  - Timeout (yarn install took longer than 10 minutes)"
    error "Check ${LOG_FILE} for detailed error messages"
    fatal "Failed to install Node packages"
  fi

  success "Node packages installed successfully"
}

#######################################
# Setup database
#######################################
setup_database() {
  step "Setting up database..."

  cd "${APP_DIR}"

  # Helper to run commands with rbenv loaded
  local rbenv_cmd="export PATH=\"\$HOME/.rbenv/bin:\$PATH\" && eval \"\$(rbenv init -)\" && "

  # Verify database is ready before attempting operations
  info "Verifying PostgreSQL is ready for connections..."
  local db_ready=false
  local db_attempts=0
  local db_max_attempts=10

  while [ $db_attempts -lt $db_max_attempts ]; do
    if sudo -u postgres psql -c "SELECT 1" &>> "${LOG_FILE}"; then
      success "PostgreSQL is ready"
      db_ready=true
      break
    fi

    db_attempts=$((db_attempts + 1))
    if [ $db_attempts -lt $db_max_attempts ]; then
      warning "PostgreSQL not ready yet, waiting... (attempt ${db_attempts}/${db_max_attempts})"
      sleep 2
    fi
  done

  if [ "$db_ready" != "true" ]; then
    fatal "PostgreSQL is not ready for connections. Cannot proceed with database setup."
  fi

  # Create database first
  info "Creating database..."
  if ! sudo -u "${DEPLOY_USER}" bash -c "${rbenv_cmd} cd ${APP_DIR} && RAILS_ENV=production bundle exec rails db:create" >> "${LOG_FILE}" 2>&1; then
    warning "Database creation failed (may already exist)"
    # Don't fail here - database might already exist
  else
    success "Database created"
  fi

  # Run migrations with retry logic (migrations can fail due to transient DB issues)
  info "Running database migrations (with retry on failure)..."
  if ! retry_command 3 2 sudo -u "${DEPLOY_USER}" bash -c "${rbenv_cmd} cd ${APP_DIR} && RAILS_ENV=production bundle exec rails db:migrate"; then
    error "Failed to run database migrations after multiple attempts"
    error "This may be due to:"
    error "  - Database connection issues"
    error "  - Migration errors in the code"
    error "  - Database permission issues"
    error "Check ${LOG_FILE} for detailed error messages"
    fatal "Failed to run database migrations"
  fi
  success "Database migrations completed"

  # Load seeds if present
  if [ -f "${APP_DIR}/db/seeds.rb" ]; then
    info "Loading database seeds..."
    sudo -u "${DEPLOY_USER}" bash -c "${rbenv_cmd} cd ${APP_DIR} && RAILS_ENV=production bundle exec rails db:seed" >> "${LOG_FILE}" 2>&1 || true
  fi

  success "Database setup complete"
}

#######################################
# Precompile assets
#######################################
precompile_assets() {
  step "Precompiling assets (this may take 5-10 minutes)..."

  cd "${APP_DIR}"

  # Check available disk space before precompilation
  local available_disk
  available_disk=$(df "${APP_DIR}" | tail -1 | awk '{print $4}')
  if [ "$available_disk" -lt 1048576 ]; then  # Less than 1GB in KB
    warning "Low disk space ($(($available_disk / 1024))MB available). Asset precompilation may fail."
  fi

  # Helper to run commands with rbenv loaded
  local rbenv_cmd="export PATH=\"\$HOME/.rbenv/bin:\$PATH\" && eval \"\$(rbenv init -)\" && "

  # Precompile assets as deploy user with timeout
  info "Running asset precompilation (timeout: 15 minutes)..."
  if ! run_with_timeout 900 sudo -u "${DEPLOY_USER}" bash -c "${rbenv_cmd} cd ${APP_DIR} && RAILS_ENV=production bundle exec rails assets:precompile"; then
    error "Failed to precompile assets"
    error "This may be due to:"
    error "  - Insufficient disk space"
    error "  - JavaScript/CSS compilation errors"
    error "  - Memory issues during compilation"
    error "  - Timeout (precompilation took longer than 15 minutes)"
    error "Check ${LOG_FILE} for detailed error messages"
    fatal "Failed to precompile assets"
  fi

  success "Assets precompiled successfully"
}

#######################################
# Create admin user
#######################################
create_admin_user() {
  step "Creating admin user..."

  cd "${APP_DIR}"

  # Helper to run commands with rbenv loaded
  local rbenv_cmd="export PATH=\"\$HOME/.rbenv/bin:\$PATH\" && eval \"\$(rbenv init -)\" && "

  # Create admin user via Rails console
  local create_admin_script="
    user = User.find_or_initialize_by(email: '${ADMIN_EMAIL}')
    user.password = '${ADMIN_PASSWORD}'
    user.password_confirmation = '${ADMIN_PASSWORD}'
    user.role = 'admin'
    user.skip_confirmation! if user.respond_to?(:skip_confirmation!)

    if user.save
      puts 'Admin user created successfully'
    else
      puts \"Failed to create admin user: #{user.errors.full_messages.join(', ')}\"
      exit 1
    end
  "

  if timeout 60 sudo -u "${DEPLOY_USER}" bash -c "${rbenv_cmd} cd ${APP_DIR} && RAILS_ENV=production bundle exec rails runner \"${create_admin_script}\"" >> "${LOG_FILE}" 2>&1; then
    success "Admin user created: ${ADMIN_EMAIL}"
  else
    warning "Failed to create admin user automatically (timed out or error occurred)"
    warning "You can create it manually after installation via Rails console"
  fi
}

#######################################
# Setup log rotation
#######################################
setup_log_rotation() {
  step "Configuring log rotation..."

  cat > /etc/logrotate.d/veracity << EOF
${APP_DIR}/log/*.log {
    daily
    missingok
    rotate 14
    compress
    delaycompress
    notifempty
    copytruncate
    su ${DEPLOY_USER} ${DEPLOY_USER}
}
EOF

  success "Log rotation configured"
}

#######################################
# Create necessary directories
#######################################
create_app_directories() {
  step "Creating application directories..."

  local dirs=(
    "${APP_DIR}/tmp"
    "${APP_DIR}/tmp/pids"
    "${APP_DIR}/tmp/cache"
    "${APP_DIR}/tmp/sockets"
    "${APP_DIR}/log"
    "${APP_DIR}/public/assets"
    "${APP_DIR}/storage"
  )

  for dir in "${dirs[@]}"; do
    mkdir -p "${dir}"
    chown "${DEPLOY_USER}:${DEPLOY_USER}" "${dir}"
  done

  success "Application directories created"
}

#######################################
# Setup application for Veracity
# Main function that orchestrates application setup
#######################################
setup_application() {
  clone_repository
  create_app_directories
  generate_env_file
  install_gems
  install_node_packages
  setup_database
  precompile_assets
  create_admin_user
  setup_log_rotation

  success "Application setup complete!"

  info "Application: ${APP_DIR}"
  info "Environment: production"
  info "Deploy user: ${DEPLOY_USER}"
}

# If script is executed directly, run setup
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # Validate required environment variables
  required_vars=(
    "SECRET_KEY_BASE"
    "DB_USER"
    "DB_PASSWORD"
    "SALT_API_USER"
    "SALT_API_PASSWORD"
    "ADMIN_EMAIL"
    "ADMIN_PASSWORD"
    "RAILS_HOST"
  )

  for var in "${required_vars[@]}"; do
    if [ -z "${!var:-}" ]; then
      fatal "Required environment variable not set: ${var}"
    fi
  done

  setup_application
fi
