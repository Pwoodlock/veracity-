# frozen_string_literal: true

class VulnerabilityAlert < ApplicationRecord
  # Associations
  belongs_to :cve_watchlist, optional: true
  belongs_to :server, optional: true

  # Validations
  validates :cve_id, presence: true
  validates :cve_id, uniqueness: { scope: :server_id }
  validates :status, inclusion: { in: %w[new acknowledged investigating patched ignored] }
  validates :severity, inclusion: { in: %w[CRITICAL HIGH MEDIUM LOW INFO] }, allow_nil: true

  # Scopes
  scope :active, -> { where.not(status: %w[patched ignored]) }
  scope :unresolved, -> { where(status: %w[new acknowledged investigating]) }
  scope :critical, -> { where(severity: 'CRITICAL') }
  scope :high, -> { where(severity: 'HIGH') }
  scope :exploited, -> { where(is_exploited: true) }
  scope :recent, -> { order(published_at: :desc) }
  scope :for_server, ->(server_id) { where(server_id: server_id) }
  scope :global_alerts, -> { where(server_id: nil) }

  # Callbacks
  after_create :update_server_vulnerability_counts
  after_update :update_server_vulnerability_counts, if: :saved_change_to_status?
  after_destroy :update_server_vulnerability_counts

  # Class methods
  def self.severities
    %w[CRITICAL HIGH MEDIUM LOW INFO]
  end

  def self.statuses
    %w[new acknowledged investigating patched ignored]
  end

  def self.severity_order
    { 'CRITICAL' => 0, 'HIGH' => 1, 'MEDIUM' => 2, 'LOW' => 3, 'INFO' => 4 }
  end

  def self.by_severity
    order(
      Arel.sql(
        "CASE severity
         WHEN 'CRITICAL' THEN 0
         WHEN 'HIGH' THEN 1
         WHEN 'MEDIUM' THEN 2
         WHEN 'LOW' THEN 3
         WHEN 'INFO' THEN 4
         ELSE 5
         END"
      )
    )
  end

  # Instance methods
  def severity_badge_class
    case severity
    when 'CRITICAL'
      'badge-danger'
    when 'HIGH'
      'badge-warning'
    when 'MEDIUM'
      'badge-info'
    when 'LOW'
      'badge-secondary'
    when 'INFO'
      'badge-light'
    else
      'badge-secondary'
    end
  end

  def status_badge_class
    case status
    when 'new'
      'badge-danger'
    when 'acknowledged'
      'badge-warning'
    when 'investigating'
      'badge-info'
    when 'patched'
      'badge-success'
    when 'ignored'
      'badge-secondary'
    else
      'badge-light'
    end
  end

  def active?
    !%w[patched ignored].include?(status)
  end

  def critical?
    severity == 'CRITICAL'
  end

  def high_priority?
    critical? || (severity == 'HIGH' && is_exploited)
  end

  def acknowledge!(user)
    update!(
      status: 'acknowledged',
      acknowledged_at: Time.current,
      acknowledged_by: user.email
    )
  end

  def mark_as_patched!(user)
    update!(
      status: 'patched',
      resolved_at: Time.current,
      resolved_by: user.email
    )
  end

  def mark_as_ignored!(user, reason = nil)
    update!(
      status: 'ignored',
      resolved_at: Time.current,
      resolved_by: user.email,
      notes: [notes, "Ignored: #{reason}"].compact.join("\n")
    )
  end

  def days_since_published
    return nil unless published_at
    ((Time.current - published_at) / 1.day).to_i
  end

  def overdue?
    return false unless active?

    case severity
    when 'CRITICAL'
      days_since_published && days_since_published > 7
    when 'HIGH'
      days_since_published && days_since_published > 30
    when 'MEDIUM'
      days_since_published && days_since_published > 90
    else
      false
    end
  end

  # Extract key information from vulnerability data
  def cvss_base_score
    vulnerability_data.dig('cvss', 'base_score') || cvss_score
  end

  def attack_vector
    vulnerability_data.dig('cvss', 'attack_vector') ||
      vulnerability_data.dig('cvss_v3', 'attackVector')
  end

  def attack_complexity
    vulnerability_data.dig('cvss', 'attack_complexity') ||
      vulnerability_data.dig('cvss_v3', 'attackComplexity')
  end

  def references
    vulnerability_data['references'] || []
  end

  def cwe_ids
    vulnerability_data['cwe_ids'] || []
  end

  def affected_products
    vulnerability_data['affected_products'] || []
  end

  # Create alert from PyVulnerabilityLookup data
  def self.create_from_vulnerability_data(cve_id, vuln_data, watchlist: nil, server: nil)
    # Parse severity from CVSS score
    severity = calculate_severity(vuln_data['cvss_score'])

    # Check if it's in CISA KEV
    is_exploited = vuln_data['kev'].present? || vuln_data['exploited'] == true

    create!(
      cve_id: cve_id,
      cve_watchlist: watchlist,
      server: server,
      severity: severity,
      cvss_score: vuln_data['cvss_score'],
      cvss_vector: vuln_data['cvss_vector'],
      epss_score: vuln_data['epss_score'],
      description: vuln_data['description'] || vuln_data['summary'],
      solution: vuln_data['solution'] || extract_solution(vuln_data),
      vulnerability_data: vuln_data,
      is_exploited: is_exploited,
      has_patch: vuln_data['patch_available'] || false,
      published_at: parse_date(vuln_data['published']),
      modified_at: parse_date(vuln_data['modified']),
      status: 'new'
    )
  end

  def self.calculate_severity(cvss_score)
    return 'INFO' unless cvss_score

    score = cvss_score.to_f
    case score
    when 9.0..10.0
      'CRITICAL'
    when 7.0...9.0
      'HIGH'
    when 4.0...7.0
      'MEDIUM'
    when 0.1...4.0
      'LOW'
    else
      'INFO'
    end
  end

  def self.extract_solution(vuln_data)
    solutions = []

    if vuln_data['patches'].present?
      solutions << "Patches available: #{vuln_data['patches'].join(', ')}"
    end

    if vuln_data['mitigation'].present?
      solutions << "Mitigation: #{vuln_data['mitigation']}"
    end

    if vuln_data['workaround'].present?
      solutions << "Workaround: #{vuln_data['workaround']}"
    end

    solutions.any? ? solutions.join("\n") : 'No solution available yet. Monitor vendor advisories.'
  end

  def self.parse_date(date_string)
    return nil unless date_string
    DateTime.parse(date_string)
  rescue ArgumentError
    nil
  end

  private

  def update_server_vulnerability_counts
    return unless server

    active_alerts = server.vulnerability_alerts.active
    server.update_columns(
      vulnerability_count: active_alerts.count,
      critical_vulnerability_count: active_alerts.critical.count
    )
  end
end